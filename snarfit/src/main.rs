use chrono::DateTime;
use chrono::Local;
use clap::Parser;
use state::initialize_state;
use std::fs::File;
use std::path::PathBuf;

mod state;

pub struct FState {
    // f_state in foremost code
    pub mode: Mode,
    pub config_file: PathBuf,
    pub input_file: Option<String>,
    pub output_directory: PathBuf,
    pub start_time: DateTime<Local>,
    pub invocation: String,
    pub audit_file_name: String,
    pub audit_file: Option<File>,
    pub audit_file_open: bool,
    pub num_builtin: u32,
    pub chunk_size: u32,
    pub fileswritten: i32,
    pub block_size: i32,
    pub skip: i32,
    pub time_stamp: DateTime<Local>,
}

pub enum Mode {
    None,
    Verbose,
    Quiet,
    IndBlk,
    Quick,
    WriteAll,
    WriteAudit,
    MultiFile,
}

pub const DEFAULT_CONFIG_FILE: &str = "foremost.conf";
pub const DEFAULT_OUTPUT_DIRECTORY: &str = "output";
/* DEFAULT CHUNK SIZE In MB */
pub const CHUNK_SIZE: u32 = 100;
pub const AUTHOR: &str = "Riko Naka";
pub const ABOUT: &str = "Rust translation and optimization of foremost tool";
pub const LONG_ABOUT: &str = "Snarfit is a console program to recover files based on their headers, footers, and internal data structures. This process is commonly referred to as data carving. Snarfit can work on image files, such as those generated by dd, Safeback, Encase, etc, or directly on a drive. The headers and footers can be specified by a configuration file or you can use command line switches to specify built-in file types. These built-in types look at the data structures of a given file format allowing for a more reliable and faster recovery.";

#[derive(Parser, Debug)]
#[command(version, about=ABOUT, author=AUTHOR, long_about = None)]
struct Args {
    /// Specify file type (-t jpeg,pdf .etc)
    #[arg(short, long, default_value = "jpeg")]
    file_type: String,

    /// Turn on indirect block detection (for UNIX file-systems)
    #[arg(short, long, action)]
    unix_detect: bool,

    /// Specify input file (default is stdin)
    #[arg(short, long, action)]
    input: bool,

    /// Write all headers, perform no error detection (corrupted files)
    #[arg(long, action)]
    write_all: bool,

    /// Only write the audit file, do not write any detected files to the disk
    #[arg(long, action)]
    write_audit: bool,

    /// Set output directory
    #[arg(short, long, default_value = DEFAULT_OUTPUT_DIRECTORY)]
    output: String,

    /// Set configuration file to use
    #[arg(short, long, default_value = DEFAULT_CONFIG_FILE)]
    config: String,

    /// Quiet mode, suppress output messages
    #[arg(short, long, action)]
    quiet: bool,

    /// Verbose mode, logs all messages to screen
    #[arg(short, long, action)]
    verbose: bool,
}

fn main() {
    let mut s = match initialize_state() {
        Ok(s) => s,
        Err(e) => panic!("unable to initialize state: {}", e),
    };

    let args = Args::parse();

    if args.verbose {
        s.mode = Mode::Verbose;
    } else if args.unix_detect {
        s.mode = Mode::IndBlk;
    } else if args.write_audit {
        s.mode = Mode::WriteAudit;
    } else if args.write_all {
        s.mode = Mode::WriteAll;
    }
}

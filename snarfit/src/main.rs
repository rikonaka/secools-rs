use chrono::DateTime;
use chrono::Local;
use clap::Parser;
use state::initialize_state;
use std::fs::File;
use std::path::PathBuf;

mod state;

pub struct FState {
    // f_state in foremost code
    pub mode: Mode,
    pub config_file: PathBuf,
    pub input_file: String,
    pub output_directory: PathBuf,
    pub start_time: DateTime<Local>,
    pub invocation: String,
    pub audit_file_name: String,
    pub audit_file: Option<File>,
    pub audit_file_open: bool,
    pub chunk_size: u32,
    pub fileswritten: i32,
    pub block_size: u32,
    pub skip: u32,
    pub s_spec: Vec<SSpec>,
}

pub struct SSpec {
    // s_spec in foremost code
    pub suffix: String,
    pub type_: Type,
    pub max_len: usize,
    pub header: String,
    pub header_len: usize,
    pub header_bm_table: Vec<usize>,
    pub footer: String,
    pub footer_len: usize,
    pub footer_bm_table: Vec<usize>,
    pub markerlist: Vec<Marker>,
    pub num_markers: usize,
    pub searchtype: usize,
    pub case_sen: usize,
    pub found: usize,
    pub comment: String,
    pub written: usize,
}

pub struct Marker {
    pub value: String,
    pub len: usize,
    pub marker_bm_table: Vec<usize>,
}

pub enum Mode {
    None,
    Verbose,
    Quiet,
    IndBlk,
    Quick,
    WriteAll,
    WriteAudit,
    MultiFile,
}

pub enum Type {
    JPEG,
    GIF,
    BMP,
    MPG,
    PDF,
    DOC,
    AVI,
    WMV,
    HTM,
    ZIP,
    MOV,
    XLS,
    PPT,
    WPD,
    CPP,
    OLE,
    GZIP,
    RIFF,
    WAV,
    VJPEG,
    SXW,
    SXC,
    SXI,
    CONF,
    PNG,
    RAR,
    EXE,
    ELF,
    REG,
    DOCX,
    XLSX,
    PPTX,
    MP4,
}

pub const DEFAULT_CONFIG_FILE: &str = "foremost.conf";
pub const DEFAULT_OUTPUT_DIRECTORY: &str = "output";
/* DEFAULT CHUNK SIZE In MB */
pub const CHUNK_SIZE: u32 = 100;
pub const SKIP: u32 = 0;
pub const AUTHOR: &str = "Riko Naka";
pub const ABOUT: &str = "Rust translation and optimization of foremost tool";
pub const LONG_ABOUT: &str = "Snarfit is a console program to recover files based on their headers, footers, and internal data structures. This process is commonly referred to as data carving. Snarfit can work on image files, such as those generated by dd, Safeback, Encase, etc, or directly on a drive. The headers and footers can be specified by a configuration file or you can use command line switches to specify built-in file types. These built-in types look at the data structures of a given file format allowing for a more reliable and faster recovery.";

#[derive(Parser, Debug)]
#[command(version, about=ABOUT, author=AUTHOR, long_about = None)]
struct Args {
    /// Specify file type (-t jpeg,pdf .etc)
    #[arg(short, long, default_value = "jpeg")]
    file_type: String,

    /// Multi file type
    #[arg(short, long, action)]
    multi_file_type: bool,

    /// Turn on indirect block detection (for UNIX file-systems)
    #[arg(short, long, action)]
    unix_detect: bool,

    /// Write all headers, perform no error detection (corrupted files)
    #[arg(long, action)]
    write_all: bool,

    /// Only write the audit file, do not write any detected files to the disk
    #[arg(long, action)]
    write_audit: bool,

    /// Specify input file (default is stdin)
    #[arg(short, long, default_value = "")]
    input: String,

    /// Set output directory
    #[arg(short, long, default_value = DEFAULT_OUTPUT_DIRECTORY)]
    output: String,

    /// Set configuration file to use
    #[arg(short, long, default_value = DEFAULT_CONFIG_FILE)]
    config: String,

    /// Set chunk size
    #[arg(short, long, default_value_t = CHUNK_SIZE)]
    chunk_size: u32,

    /// Skip first bits
    #[arg(short, long, default_value_t = SKIP)]
    skip: u32,

    /// Quiet mode, suppress output messages
    #[arg(long, action)]
    quiet: bool,

    /// Quick mode. Search are performed on 512 byte boundaries
    #[arg(short, long, action)]
    quick: bool,

    /// Verbose mode, logs all messages to screen
    #[arg(short, long, action)]
    verbose: bool,
}

fn main() {
    let mut s = match initialize_state() {
        Ok(s) => s,
        Err(e) => panic!("unable to initialize state: {}", e),
    };

    let args = Args::parse();

    if args.verbose {
        s.mode = Mode::Verbose;
    } else if args.unix_detect {
        s.mode = Mode::IndBlk;
    } else if args.write_audit {
        s.mode = Mode::WriteAudit;
    } else if args.write_all {
        s.mode = Mode::WriteAll;
    } else if args.quiet {
        s.mode = Mode::Quiet;
    } else if args.quick {
        s.mode = Mode::Quick;
    } else if args.multi_file_type {
        s.mode = Mode::MultiFile;
    }

    s.output_directory = match state::set_canonicalize_file(&args.output) {
        Ok(p) => p,
        Err(e) => panic!("unable to set output directory: {}", e),
    };

    s.config_file = match state::set_canonicalize_file(&args.config) {
        Ok(p) => p,
        Err(e) => panic!("unable to set config file: {}", e),
    };

    s.chunk_size = args.chunk_size;

    s.input_file = args.input;
}
